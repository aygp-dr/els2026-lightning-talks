#+TITLE: ELS 2026 Lightning Talk Proposals
#+AUTHOR: Your Name
#+DATE: 2025-05-21
#+OPTIONS: toc:3 num:t
#+EXPORT_FILE_NAME: ELS2026-Lightning-Talks
#+STARTUP: overview
#+PROPERTY: header-args :mkdirp yes

* Introduction
:PROPERTIES:
:EXPORT_TITLE: ELS 2026 Lightning Talk Proposals
:END:

This document contains five detailed proposals for lightning talks at the European Lisp Symposium 2026. Each talk builds upon themes from ELS 2025 while exploring new directions that would benefit the Common Lisp community.

** Selection Criteria
- *Novelty*: How original is the concept in the Lisp ecosystem?
- *Impact*: Practical benefit to Lisp developers and researchers
- *Demo Quality*: Ability to showcase compelling live demonstrations
- *Implementation Feasibility*: Can be completed within the development timeline
- *Community Interest*: Addresses current needs or emerging trends

* Talk 1: Bidirectional Code Generation with Lisp and LLMs
:PROPERTIES:
:CUSTOM_ID: bidirectional-llm
:EXPORT_TITLE: Bidirectional Code Generation with Lisp and LLMs
:END:

** Abstract
A system that enables bidirectional communication between Large Language Models and Common Lisp environments, where Lisp code can generate prompts for LLMs and LLMs can produce executable Lisp code that modifies the generating system itself.

** Motivation
Current AI-assisted programming tools treat code generation as a one-way process. This talk demonstrates how Lisp's homoiconicity enables a more sophisticated bidirectional relationship where:
- Lisp programs can construct and modify their own prompts
- Generated code can alter the prompt generation logic
- The system becomes self-improving through iterative refinement

** Technical Innovation
*** Core Architecture
#+BEGIN_SRC mermaid :file presentations/01-llm-lisp-bidirectional/slides/architecture.png :exports both
graph TD
    A[Lisp Environment] -->|S-expressions as prompts| B[LLM API]
    B -->|Generated code| C[Code Parser]
    C -->|AST| D[Safety Validator]
    D -->|Safe code| E[Evaluator]
    E -->|Results & Context| A
    
    F[Prompt Templates] -->|Structure| A
    A -->|Updates| F
    
    G[Knowledge Base] -->|Context| B
    E -->|Learning| G
    
    H[User Interface] -->|Commands| A
    A -->|Status| H
#+END_SRC

*** Key Components
**** Prompt Generator
#+BEGIN_SRC lisp :tangle presentations/01-llm-lisp-bidirectional/code/prompt-generator.lisp :exports code
(defpackage :bidirectional-llm/prompts
  (:use :cl)
  (:export :generate-prompt :update-template :learn-from-result))

(in-package :bidirectional-llm/prompts)

(defclass prompt-template ()
  ((name :initarg :name :accessor template-name)
   (structure :initarg :structure :accessor template-structure)
   (success-rate :initform 0.0 :accessor template-success-rate)
   (usage-count :initform 0 :accessor template-usage-count)))

(defvar *prompt-templates* (make-hash-table :test #'equal))

(defun generate-prompt (context function-signature docstring)
  "Generate a contextual prompt for LLM code completion"
  (let ((template (gethash (infer-template-type context) *prompt-templates*)))
    (format nil "~A~%Context: ~A~%Signature: ~A~%Documentation: ~A~%Generate implementation:"
            (template-structure template)
            (serialize-context context)
            function-signature
            docstring)))

(defun update-template (template-name success-p feedback)
  "Update template based on generation results"
  (let ((template (gethash template-name *prompt-templates*)))
    (when template
      (incf (template-usage-count template))
      (setf (template-success-rate template)
            (/ (+ (* (template-success-rate template) 
                     (1- (template-usage-count template)))
                  (if success-p 1.0 0.0))
               (template-usage-count template)))
      (when feedback
        (adapt-template-structure template feedback)))))
#+END_SRC

**** Code Safety Validator
#+BEGIN_SRC lisp :tangle presentations/01-llm-lisp-bidirectional/code/safety-validator.lisp :exports code
(defpackage :bidirectional-llm/safety
  (:use :cl)
  (:export :validate-generated-code :safe-eval))

(in-package :bidirectional-llm/safety)

(defvar *dangerous-symbols* 
  '(delete-file delete-directory format-hard-disk
    eval compile load require
    sb-ext:run-program uiop:run-program))

(defvar *allowed-packages*
  '(:cl :alexandria :bidirectional-llm))

(defun validate-generated-code (code-string)
  "Validate that generated code is safe to evaluate"
  (handler-case
      (let ((parsed (read-from-string code-string)))
        (and (validate-symbols parsed)
             (validate-packages parsed)
             (validate-structure parsed)))
    (error (c)
      (warn "Code validation failed: ~A" c)
      nil)))

(defun validate-symbols (form)
  "Check for dangerous symbols in the form"
  (typecase form
    (symbol (not (member form *dangerous-symbols*)))
    (cons (and (validate-symbols (car form))
               (validate-symbols (cdr form))))
    (t t)))

(defun safe-eval (code-string context)
  "Safely evaluate generated code with limited privileges"
  (when (validate-generated-code code-string)
    (let ((*package* (find-package :bidirectional-llm))
          (*read-eval* nil))
      (handler-case
          (eval (read-from-string code-string))
        (error (c)
          (warn "Evaluation error: ~A" c)
          nil)))))
#+END_SRC

** Demo Script
*** Setup Phase (1 minute)
1. *Show empty Lisp function with docstring*
   #+BEGIN_SRC lisp :exports code
   (defun fibonacci-optimized (n)
     "Calculate fibonacci number using memoization for efficiency"
     ;; TO-IMPLEMENT
     )
   #+END_SRC

2. *Initialize bidirectional system*
   #+BEGIN_SRC lisp :exports code
   (bidirectional-llm:start-session :model "claude-3-sonnet")
   #+END_SRC

*** Generation Phase (2 minutes)
1. *Trigger automatic prompt generation*
   #+BEGIN_SRC lisp :exports code
   (bidirectional-llm:complete-function 'fibonacci-optimized)
   #+End_SRC

2. *Show generated prompt (formatted for LLM)*
3. *Receive and evaluate generated implementation*
4. *Demonstrate the working function*

*** Self-Improvement Phase (2 minutes)
1. *Show how the system learns from results*
   #+BEGIN_SRC lisp :exports code
   (bidirectional-llm:analyze-performance 'fibonacci-optimized)
   #+END_SRC

2. *Generate improved prompt based on performance*
3. *Show iteration producing better implementation*
4. *Demonstrate bidirectional feedback loop*

** Key Takeaways
- Lisp's symbolic nature makes it ideal for AI collaboration
- Self-modifying prompt generation enables continuous improvement  
- Safety validation prevents dangerous code execution
- Bidirectional flow creates emergent intelligent behavior

** Implementation Status
- [ ] Core prompt generation system (40% complete)
- [ ] LLM API integration (20% complete)
- [ ] Safety validation framework (60% complete)
- [ ] Bidirectional feedback loop (10% complete)
- [ ] Demo application (30% complete)

* Talk 2: REPL-Driven Observability for Distributed Lisp Systems
:PROPERTIES:
:CUSTOM_ID: repl-observability
:EXPORT_TITLE: REPL-Driven Observability for Distributed Lisp Systems
:END:

** Abstract
A framework that extends the Common Lisp REPL across distributed systems, enabling real-time debugging, monitoring, and manipulation of multiple Lisp processes as if they were part of a single interactive environment.

** Motivation
Modern applications often involve multiple Lisp processes across different machines, but traditional debugging tools break down in distributed environments. This system brings Lisp's interactive development philosophy to distributed systems by creating a unified REPL experience.

** System Architecture
#+BEGIN_SRC mermaid :file presentations/02-repl-observability/slides/distributed-repl.png :exports both
graph TB
    subgraph "Development Machine"
        A[Master REPL]
        B[Visualization Dashboard]
        C[Command Dispatcher]
    end
    
    subgraph "Production Cluster"
        D[Node 1 - Web Server]
        E[Node 2 - Database]
        F[Node 3 - Worker Queue]
    end
    
    subgraph "Staging Environment"
        G[Node 4 - API Gateway]
        H[Node 5 - Cache Layer]
    end
    
    A -->|Commands| C
    C -->|Distributed Execution| D
    C -->|Distributed Execution| E
    C -->|Distributed Execution| F
    C -->|Distributed Execution| G
    C -->|Distributed Execution| H
    
    D -->|Telemetry| B
    E -->|Telemetry| B
    F -->|Telemetry| B
    G -->|Telemetry| B
    H -->|Telemetry| B
    
    B -->|Alerts| A
#+END_SRC

** Core Components
*** Distributed REPL Server
#+BEGIN_SRC lisp :tangle presentations/02-repl-observability/code/distributed-repl.lisp :exports code
(defpackage :distributed-repl
  (:use :cl :usocket :bordeaux-threads)
  (:export :start-repl-server :connect-to-cluster :execute-on-nodes))

(in-package :distributed-repl)

(defclass distributed-repl-server ()
  ((port :initarg :port :accessor server-port :initform 4005)
   (nodes :initform (make-hash-table :test #'equal) :accessor server-nodes)
   (command-history :initform '() :accessor server-history)
   (active-sessions :initform '() :accessor server-sessions)))

(defvar *repl-server* nil)

(defun start-repl-server (&key (port 4005))
  "Start the distributed REPL server"
  (setf *repl-server* (make-instance 'distributed-repl-server :port port))
  (let ((server-socket (socket-listen *wildcard-host* port :reuse-address t)))
    (format t "Distributed REPL server started on port ~A~%" port)
    (make-thread 
     (lambda ()
       (loop
         (let ((client-socket (socket-accept server-socket)))
           (make-thread 
            (lambda () (handle-client-connection client-socket))
            :name "repl-client-handler"))))
     :name "repl-server")))

(defun register-node (node-id host port capabilities)
  "Register a new node in the distributed system"
  (setf (gethash node-id (server-nodes *repl-server*))
        (list :host host :port port :capabilities capabilities
              :status :connected :last-seen (get-universal-time))))

(defun execute-on-nodes (expression &key nodes (timeout 30))
  "Execute expression on specified nodes (or all if none specified)"
  (let ((target-nodes (or nodes (hash-table-keys (server-nodes *repl-server*)))))
    (mapcar (lambda (node-id)
              (execute-on-single-node node-id expression timeout))
            target-nodes)))

(defun execute-on-single-node (node-id expression timeout)
  "Execute expression on a single node with timeout"
  (let ((node-info (gethash node-id (server-nodes *repl-server*))))
    (when node-info
      (handler-case
          (with-timeout (timeout)
            (let ((result (send-command-to-node node-info expression)))
              (list :node node-id :status :success :result result)))
        (timeout-error ()
          (list :node node-id :status :timeout))
        (error (e)
          (list :node node-id :status :error :error (princ-to-string e)))))))
#+END_SRC

*** Telemetry Collection
#+BEGIN_SRC lisp :tangle presentations/02-repl-observability/code/telemetry.lisp :exports code
(defpackage :distributed-repl/telemetry
  (:use :cl)
  (:export :collect-system-metrics :track-function-calls :create-metric-dashboard))

(in-package :distributed-repl/telemetry)

(defclass metric-collector ()
  ((metrics :initform (make-hash-table :test #'equal) :accessor collector-metrics)
   (collection-interval :initarg :interval :accessor collection-interval :initform 1)
   (active-p :initform nil :accessor collector-active-p)))

(defvar *metric-collector* (make-instance 'metric-collector))

(defun start-metric-collection (&key (interval 1))
  "Start collecting system metrics at specified interval"
  (setf (collection-interval *metric-collector*) interval)
  (setf (collector-active-p *metric-collector*) t)
  (bordeaux-threads:make-thread
   (lambda ()
     (loop while (collector-active-p *metric-collector*)
           do (collect-system-metrics)
              (sleep interval)))
   :name "metric-collector"))

(defun collect-system-metrics ()
  "Collect current system metrics"
  (let ((timestamp (get-universal-time)))
    (setf (gethash timestamp (collector-metrics *metric-collector*))
          (list :memory-usage (get-memory-usage)
                :cpu-usage (get-cpu-usage)
                :thread-count (length (bordeaux-threads:all-threads))
                :heap-size (get-heap-size)
                :gc-stats (get-gc-statistics)))))

(defmacro with-telemetry (function-name &body body)
  "Wrap function execution with telemetry collection"
  `(let ((start-time (get-internal-real-time))
         (start-memory (get-memory-usage)))
     (unwind-protect
          (progn ,@body)
       (let ((end-time (get-internal-real-time))
             (end-memory (get-memory-usage)))
         (record-function-telemetry 
          ',function-name
          :duration (- end-time start-time)
          :memory-delta (- end-memory start-memory))))))

(defun create-real-time-dashboard ()
  "Generate HTML dashboard for real-time metrics"
  (format nil "
<html>
<head><title>Distributed Lisp System Dashboard</title></head>
<body>
<h1>System Health Dashboard</h1>
<div id='metrics'></div>
<script>
  function updateMetrics() {
    fetch('/api/metrics')
      .then(response => response.json())
      .then(data => {
        document.getElementById('metrics').innerHTML = formatMetrics(data);
      });
  }
  setInterval(updateMetrics, 1000);
</script>
</body>
</html>"))
#+END_SRC

** Demo Script
*** Setup (1 minute)
1. *Show 3 Lisp processes running on different "machines" (local containers)*
2. *Connect distributed REPL to all nodes*
   #+BEGIN_SRC lisp :exports code
   (distributed-repl:connect-to-cluster 
    '(("web-server" "localhost" 4001)
      ("database" "localhost" 4002) 
      ("worker" "localhost" 4003)))
   #+END_SRC

*** Live Debugging (2 minutes)
1. *Inject a bug into the web server*
   #+BEGIN_SRC lisp :exports code
   (distributed-repl:execute-on-nodes 
    '(setf *request-timeout* 0.001) 
    :nodes '("web-server"))
   #+END_SRC

2. *Show real-time dashboard detecting the issue*
3. *Debug across multiple nodes simultaneously*
   #+BEGIN_SRC lisp :exports code
   (distributed-repl:execute-on-nodes 
    '(inspect *current-requests*))
   #+END_SRC

*** Hot-Fix Deployment (2 minutes)
1. *Fix the issue across all affected nodes*
   #+BEGIN_SRC lisp :exports code
   (distributed-repl:execute-on-nodes 
    '(progn 
       (setf *request-timeout* 30)
       (restart-request-handler))
    :nodes '("web-server"))
   #+END_SRC

2. *Show system recovery in real-time*
3. *Demonstrate rollback capability*

** Key Benefits
- Maintains Lisp's interactive development philosophy in production
- Enables real-time debugging across distributed systems
- Provides unified view of system health and behavior
- Allows hot-fixes without service interruption

** Implementation Roadmap
- [x] Basic REPL server framework (80% complete)
- [ ] Secure authentication and authorization (40% complete)
- [ ] Real-time telemetry dashboard (60% complete)
- [ ] Command history and replay (30% complete)
- [ ] Integration with common deployment tools (20% complete)

* Talk 3: Incremental Type Inference for Common Lisp
:PROPERTIES:
:CUSTOM_ID: incremental-types
:EXPORT_TITLE: Incremental Type Inference for Common Lisp
:END:

** Abstract
A development-time type inference system that builds type knowledge incrementally as code is written and tested, providing optional static analysis benefits while preserving Lisp's dynamic nature.

** Innovation
Unlike traditional static type systems, this approach:
- Learns types from REPL interactions and test execution
- Provides suggestions rather than requirements
- Integrates with existing Common Lisp development workflow
- Builds confidence in type information over time

** Type Learning Architecture
#+BEGIN_SRC mermaid :file presentations/03-incremental-types/slides/type-learning.png :exports both
graph TD
    A[Code Editor] -->|Source code| B[Parser]
    B -->|AST| C[Type Inference Engine]
    
    D[REPL Session] -->|Runtime values| E[Value Tracer]
    E -->|Type observations| C
    
    F[Test Suite] -->|Test execution| G[Test Tracer]
    G -->|Type constraints| C
    
    C -->|Inferred types| H[Type Database]
    H -->|Type hints| A
    H -->|Warnings| I[Developer Feedback]
    
    J[Static Analysis] -->|Additional constraints| C
    K[Documentation] -->|Type annotations| C
#+END_SRC

** Core Implementation
*** Type Inference Engine
#+BEGIN_SRC lisp :tangle presentations/03-incremental-types/code/type-inference.lisp :exports code
(defpackage :incremental-types
  (:use :cl)
  (:export :infer-types :register-observation :get-type-info :suggest-type-annotation))

(in-package :incremental-types)

(defclass type-database ()
  ((function-types :initform (make-hash-table) :accessor function-types)
   (variable-types :initform (make-hash-table) :accessor variable-types)
   (observations :initform '() :accessor type-observations)
   (confidence-scores :initform (make-hash-table) :accessor confidence-scores)))

(defvar *type-db* (make-instance 'type-database))

(defstruct type-info
  inferred-type
  confidence
  observations
  sources
  last-updated)

(defun register-observation (symbol value source)
  "Register a type observation from runtime or static analysis"
  (let ((observed-type (determine-type value))
        (existing-info (gethash symbol (function-types *type-db*))))
    (if existing-info
        (update-type-info existing-info observed-type source)
        (setf (gethash symbol (function-types *type-db*))
              (make-type-info 
               :inferred-type observed-type
               :confidence 0.1
               :observations (list value)
               :sources (list source)
               :last-updated (get-universal-time))))))

(defun determine-type (value)
  "Determine the most specific type for a value"
  (typecase value
    (integer (cond 
               ((typep value 'fixnum) 'fixnum)
               ((>= value 0) '(integer 0 *))
               (t 'integer)))
    (float (if (typep value 'single-float) 'single-float 'double-float))
    (string (if (= (length value) 0) '(string 0) `(string ,(length value))))
    (list (if (null value) 'null `(list ,@(mapcar #'determine-type value))))
    (vector `(vector ,(if (> (length value) 0) 
                          (determine-type (aref value 0)) 
                          t)
                     ,(length value)))
    (t (type-of value))))

(defun update-type-info (info new-type source)
  "Update existing type information with new observation"
  (push new-type (type-info-observations info))
  (push source (type-info-sources info))
  (setf (type-info-last-updated info) (get-universal-time))
  
  ;; Update confidence based on consistency
  (let ((consistent-observations 
          (count new-type (type-info-observations info) :test #'type-compatible-p)))
    (setf (type-info-confidence info)
          (min 1.0 (/ consistent-observations 
                      (length (type-info-observations info))))))
  
  ;; Update inferred type to most specific common type
  (setf (type-info-inferred-type info)
        (find-common-type (type-info-observations info))))

(defun type-compatible-p (type1 type2)
  "Check if two types are compatible"
  (or (equal type1 type2)
      (subtypep type1 type2)
      (subtypep type2 type1)))

(defun find-common-type (type-list)
  "Find the most specific type that encompasses all observed types"
  (reduce (lambda (acc type)
            (cond
              ((equal acc type) acc)
              ((subtypep type acc) acc)
              ((subtypep acc type) type)
              (t t))) ; Fall back to T if no common specific type
          type-list
          :initial-value (first type-list)))
#+END_SRC

*** REPL Integration
#+BEGIN_SRC lisp :tangle presentations/03-incremental-types/code/repl-tracer.lisp :exports code
(defpackage :incremental-types/repl
  (:use :cl :incremental-types)
  (:export :enable-type-tracing :disable-type-tracing :*trace-types*))

(in-package :incremental-types/repl)

(defvar *trace-types* nil)
(defvar *traced-functions* '())

(defun enable-type-tracing ()
  "Enable automatic type tracing in the REPL"
  (setf *trace-types* t)
  (advice-add 'eval :around #'trace-eval-types)
  (format t "Type tracing enabled~%"))

(defun disable-type-tracing ()
  "Disable automatic type tracing"
  (setf *trace-types* nil)
  (advice-remove 'eval #'trace-eval-types)
  (format t "Type tracing disabled~%"))

(defun trace-eval-types (original-eval form &optional env)
  "Trace types during REPL evaluation"
  (when *trace-types*
    (let ((result (funcall original-eval form env)))
      (when (and (consp form) (symbolp (car form)))
        (let ((function-name (car form))
              (args (cdr form)))
          ;; Register argument types
          (loop for arg in args
                for i from 0
                do (register-observation 
                    (intern (format nil "~A-ARG-~A" function-name i) :keyword)
                    (eval arg env)
                    :repl-execution))
          ;; Register return type
          (register-observation 
           (intern (format nil "~A-RETURN" function-name) :keyword)
           result
           :repl-execution)))
      result)))

(defmacro with-type-learning (&body body)
  "Execute body with type learning enabled"
  `(let ((*trace-types* t))
     (enable-type-tracing)
     (unwind-protect
          (progn ,@body)
       (disable-type-tracing))))

;; Example usage
(defun suggest-type-declarations (function-name)
  "Suggest type declarations based on learned types"
  (let ((arg-types '())
        (return-type nil))
    (loop for i from 0
          for arg-key = (intern (format nil "~A-ARG-~A" function-name i) :keyword)
          for type-info = (gethash arg-key (function-types *type-db*))
          while type-info
          do (push (type-info-inferred-type type-info) arg-types))
    
    (let ((return-key (intern (format nil "~A-RETURN" function-name) :keyword)))
      (when-let ((return-info (gethash return-key (function-types *type-db*))))
        (setf return-type (type-info-inferred-type return-info))))
    
    (when (or arg-types return-type)
      `(declaim (ftype (function ,(reverse arg-types) 
                                 ,(or return-type t)) 
                       ,function-name)))))
#+END_SRC

** Demo Script  
*** Setup (1 minute)
1. *Show a simple function without type annotations*
   #+BEGIN_SRC lisp :exports code
   (defun calculate-distance (x1 y1 x2 y2)
     (sqrt (+ (expt (- x2 x1) 2) 
              (expt (- y2 y1) 2))))
   #+END_SRC

2. *Enable type learning*
   #+BEGIN_SRC lisp :exports code
   (incremental-types:enable-type-tracing)
   #+END_SRC

*** Type Learning (2 minutes)
1. *Call function with various inputs*
   #+BEGIN_SRC lisp :exports code
   (calculate-distance 0 0 3 4)      ; integers
   (calculate-distance 1.5 2.5 4.5 6.5) ; floats
   (calculate-distance 0.0 0 3 4.0)  ; mixed
   #+END_SRC

2. *Show accumulated type knowledge*
   #+BEGIN_SRC lisp :exports code
   (incremental-types:get-type-info 'calculate-distance)
   #+END_SRC

*** Type Suggestions (2 minutes)
1. *Generate suggested type declarations*
   #+BEGIN_SRC lisp :exports code
   (incremental-types:suggest-type-declarations 'calculate-distance)
   ;; => (declaim (ftype (function (number number number number) 
   ;;                             (real 0 *)) 
   ;;                    calculate-distance))
   #+END_SRC

2. *Show confidence levels and conflict detection*
3. *Demonstrate integration with development environment*

** Key Advantages
- Preserves Lisp's dynamic nature while adding static analysis benefits
- Learns from actual usage patterns rather than programmer declarations
- Provides gradual typing adoption path
- Integrates seamlessly with existing development workflow

** Technical Challenges
- Handling polymorphic functions with multiple valid type signatures
- Balancing type specificity with generality
- Managing type information persistence across sessions
- Integration with macro-heavy codebases

** Implementation Progress
- [x] Basic type inference engine (70% complete)
- [x] REPL integration and tracing (60% complete)
- [ ] Editor integration and real-time feedback (30% complete)
- [ ] Test suite integration (40% complete)
- [ ] Performance optimization (20% complete)

* Talk 4: Lisp Web Components - Isomorphic Lisp for Frontend and Backend
:PROPERTIES:
:CUSTOM_ID: lisp-web-components
:EXPORT_TITLE: Lisp Web Components - Isomorphic Lisp for Frontend and Backend
:END:

** Abstract
A framework enabling Common Lisp code to run seamlessly in both browser and server environments, creating truly isomorphic web applications where components can be rendered server-side or client-side without code duplication.

** Vision
Modern web development suffers from the complexity of maintaining separate codebases for client and server. This system demonstrates how Lisp's uniform syntax and powerful macro system enable writing web components once and deploying them anywhere.

** Architecture Overview
#+BEGIN_SRC mermaid :file presentations/04-lisp-web-components/slides/isomorphic-architecture.png :exports both
graph TB
    subgraph "Development Environment"
        A[Common Lisp Source]
        A --> B[Component Definitions]
        A --> C[Business Logic]
        A --> D[Data Models]
    end
    
    subgraph "Compilation Pipeline"
        B --> E[Server Runtime]
        B --> F[JavaScript Transpiler]
        F --> G[Browser Runtime]
        
        C --> E
        C --> F
        
        D --> E
        D --> F
    end
    
    subgraph "Deployment"
        E --> H[Server-Side Rendering]
        G --> I[Client-Side Rendering]
        
        H --> J[Initial Page Load]
        I --> K[Interactive Updates]
        
        J --> L[Hydration]
        K --> L
        L --> M[Unified User Experience]
    end
    
    subgraph "Data Flow"
        N[Shared State Store]
        E <--> N
        G <--> N
    end
#+END_SRC

** Core Framework Implementation
*** Component Definition System
#+BEGIN_SRC lisp :tangle presentations/04-lisp-web-components/code/components.lisp :exports code
(defpackage :lisp-web-components
  (:use :cl)
  (:export :defcomponent :render :mount :update-state :emit-event))

(in-package :lisp-web-components)

(defmacro defcomponent (name (&rest props) &body body)
  "Define a web component that works in both server and browser environments"
  `(progn
     (defclass ,name ()
       ,(mapcar (lambda (prop)
                  `(,prop :initarg ,(intern (symbol-name prop) :keyword)
                          :accessor ,(intern (format nil "~A-~A" name prop))))
                props))
     
     (defmethod render ((component ,name))
       (let (,@(mapcar (lambda (prop)
                         `(,prop (,(intern (format nil "~A-~A" name prop)) component)))
                       props))
         ,@body))
     
     (defmethod component-name ((component ,name))
       ,(string-downcase (symbol-name name)))
     
     ;; Generate JavaScript version for browser
     #+transpile-to-js
     (generate-js-component ',name ',props ',body)))

;; Example component definition
(defcomponent todo-item (text completed-p id)
  `(:div :class ,(if completed-p "todo-item completed" "todo-item")
         (:input :type "checkbox" 
                 :checked ,completed-p
                 :onchange ,(format nil "toggleTodo('~A')" id))
         (:span :class "todo-text" ,text)
         (:button :class "delete-btn"
                  :onclick ,(format nil "deleteTodo('~A')" id)
                  "Ã—")))

(defcomponent todo-list (items)
  `(:div :class "todo-list"
         (:h2 "My Todo List")
         (:ul ,@(mapcar (lambda (item)
                          (render (make-instance 'todo-item
                                                 :text (getf item :text)
                                                 :completed-p (getf item :completed-p)
                                                 :id (getf item :id))))
                        items))
         (:form :onsubmit "addTodo(event)"
                (:input :type "text" :id "new-todo" :placeholder "Add new todo...")
                (:button :type "submit" "Add"))))

(defun render-to-html (component)
  "Render component to HTML string (server-side)"
  (labels ((serialize-element (element)
             (if (atom element)
                 (html-escape (princ-to-string element))
                 (case (first element)
                   (:text (html-escape (second element)))
                   (t (let ((tag (first element))
                            (attrs '())
                            (children '()))
                        ;; Parse attributes and children
                        (loop for item in (rest element)
                              if (keywordp item)
                                do (push item attrs)
                                   (push (pop (rest element)) attrs)
                              else
                                do (push item children))
                        (format nil "<~A~{ ~A=\"~A\"~}~@[>~{~A~}~]~@[</~A>~]"
                                (string-downcase (symbol-name tag))
                                (reverse attrs)
                                (when children 
                                  (mapcar #'serialize-element (reverse children)))
                                (when children (string-downcase (symbol-name tag))))))))))
    (serialize-element (render component))))
#+END_SRC

*** JavaScript Transpiler
#+BEGIN_SRC lisp :tangle presentations/04-lisp-web-components/code/js-transpiler.lisp :exports code
(defpackage :lisp-web-components/transpiler
  (:use :cl :lisp-web-components)
  (:export :transpile-to-javascript :generate-component-library))

(in-package :lisp-web-components/transpiler)

(defun transpile-to-javascript (lisp-form)
  "Transpile Lisp forms to equivalent JavaScript"
  (cond
    ((null lisp-form) "null")
    ((atom lisp-form)
     (typecase lisp-form
       (string (format nil "\"~A\"" lisp-form))
       (keyword (format nil "\"~A\"" (string-downcase (symbol-name lisp-form))))
       (symbol (string-downcase (symbol-name lisp-form)))
       (number (princ-to-string lisp-form))
       (t (princ-to-string lisp-form))))
    ((listp lisp-form)
     (case (first lisp-form)
       ('if (format nil "(~A ? ~A : ~A)"
                    (transpile-to-javascript (second lisp-form))
                    (transpile-to-javascript (third lisp-form))
                    (transpile-to-javascript (fourth lisp-form))))
       ('+ (format nil "(~{~A~^ + ~})"
                   (mapcar #'transpile-to-javascript (rest lisp-form))))
       ('- (format nil "(~{~A~^ - ~})"
                   (mapcar #'transpile-to-javascript (rest lisp-form))))
       ('format (format nil "`~A`"
                        (substitute-format-args (second lisp-form) (cddr lisp-form))))
       ('let (let ((bindings (second lisp-form))
                   (body (cddr lisp-form)))
               (format nil "(() => {~%~{  let ~A = ~A;~%~}~{  ~A;~%~}~})()"
                       (loop for (var val) in bindings
                             collect (string-downcase (symbol-name var))
                             collect (transpile-to-javascript val))
                       (mapcar #'transpile-to-javascript body))))
       (t (format nil "~A(~{~A~^, ~})"
                  (string-downcase (symbol-name (first lisp-form)))
                  (mapcar #'transpile-to-javascript (rest lisp-form))))))))

(defun generate-js-component (component-name props body)
  "Generate JavaScript class for a Lisp component"
  (format nil "
class ~A extends Component {
  constructor(props) {
    super(props);
    ~{this.~A = props.~A || null;~%    ~}
  }
  
  render() {
    const {~{~A~^, ~}} = this.props;
    return ~A;
  }
}

// Register component for server-side rendering compatibility
if (typeof module !== 'undefined') {
  module.exports.~A = ~A;
}"
          (string-capitalize (symbol-name component-name))
          (loop for prop in props
                collect (string-downcase (symbol-name prop))
                collect (string-downcase (symbol-name prop)))
          (mapcar (lambda (p) (string-downcase (symbol-name p))) props)
          (transpile-dom-to-jsx (first body))
          (string-capitalize (symbol-name component-name))
          (string-capitalize (symbol-name component-name))))

(defun transpile-dom-to-jsx (dom-expr)
  "Convert Lisp DOM expression to JSX"
  (cond
    ((atom dom-expr) (format nil "{~A}" (transpile-to-javascript dom-expr)))
    ((keywordp (first dom-expr))
     (let ((tag (string-downcase (symbol-name (first dom-expr))))
           (attrs '())
           (children '()))
       ;; Parse attributes and children
       (loop for rest on (cdr dom-expr)
             while (keywordp (first rest))
             do (push (format nil "~A={~A}"
                              (string-downcase (symbol-name (first rest)))
                              (transpile-to-javascript (second rest)))
                      attrs)
                (pop rest)
                (pop rest)
             finally (setf children rest))
       (format nil "<~A~@[ ~{~A~^ ~}~]~@[>~{~A~}~]~@[</~A>~]"
               tag
               (when attrs (reverse attrs))
               (when children (mapcar #'transpile-dom-to-jsx children))
               (when children tag))))
    (t (transpile-to-javascript dom-expr))))
#+END_SRC

*** State Management
#+BEGIN_SRC lisp :tangle presentations/04-lisp-web-components/code/state-management.lisp :exports code
(defpackage :lisp-web-components/state
  (:use :cl)
  (:export :create-store :subscribe :dispatch :get-state :update-state))

(in-package :lisp-web-components/state)

(defclass app-store ()
  ((state :initform (make-hash-table :test #'equal) :accessor store-state)
   (subscribers :initform '() :accessor store-subscribers)
   (middleware :initform '() :accessor store-middleware)))

(defvar *global-store* nil)

(defun create-store (&optional initial-state)
  "Create a new application store"
  (let ((store (make-instance 'app-store)))
    (when initial-state
      (setf (store-state store) 
            (alexandria:alist-hash-table initial-state :test #'equal)))
    (setf *global-store* store)
    store))

(defun get-state (&optional (store *global-store*) path)
  "Get state value, optionally at a specific path"
  (if path
      (reduce (lambda (state key)
                (if (hash-table-p state)
                    (gethash key state)
                    (getf state key)))
              (if (listp path) path (list path))
              :initial-value (store-state store))
      (alexandria:hash-table-alist (store-state store))))

(defun update-state (updates &optional (store *global-store*))
  "Update store state and notify subscribers"
  (let ((old-state (alexandria:copy-hash-table (store-state store))))
    ;; Apply updates
    (loop for (path value) in updates
          do (set-nested-value (store-state store) path value))
    
    ;; Notify subscribers
    (dolist (subscriber (store-subscribers store))
      (funcall subscriber old-state (store-state store)))
    
    (store-state store)))

(defun subscribe (callback &optional (store *global-store*))
  "Subscribe to state changes"
  (push callback (store-subscribers store))
  ;; Return unsubscribe function
  (lambda ()
    (setf (store-subscribers store)
          (remove callback (store-subscribers store)))))

(defun dispatch (action &optional (store *global-store*))
  "Dispatch an action to update state"
  (let ((action-type (getf action :type))
        (payload (getf action :payload)))
    (case action-type
      (:add-todo
       (let ((new-todo (list :id (generate-id)
                             :text (getf payload :text)
                             :completed-p nil
                             :created-at (get-universal-time))))
         (update-state `(("todos" ,(append (get-state store "todos") 
                                          (list new-todo)))))))
      (:toggle-todo
       (let ((todo-id (getf payload :id)))
         (update-state 
          `(("todos" ,(mapcar (lambda (todo)
                                (if (equal (getf todo :id) todo-id)
                                    (list* :completed-p (not (getf todo :completed-p))
                                           (alexandria:remove-from-plist todo :completed-p))
                                    todo))
                              (get-state store "todos")))))))
      (:delete-todo
       (let ((todo-id (getf payload :id)))
         (update-state 
          `(("todos" ,(remove-if (lambda (todo)
                                   (equal (getf todo :id) todo-id))
                                 (get-state store "todos"))))))))))

;; Utility functions
(defun generate-id ()
  "Generate a unique ID"
  (format nil "~A-~A" (get-universal-time) (random 1000)))

(defun set-nested-value (hash-table path value)
  "Set a value at a nested path in a hash table"
  (if (= (length path) 1)
      (setf (gethash (first path) hash-table) value)
      (let ((nested (gethash (first path) hash-table)))
        (unless nested
          (setf nested (make-hash-table :test #'equal))
          (setf (gethash (first path) hash-table) nested))
        (set-nested-value nested (rest path) value))))
#+END_SRC

** Demo Script
*** Setup (1 minute)
1. *Show a todo application component definition*
2. *Demonstrate single codebase for both environments*

*** Server-Side Rendering (1.5 minutes)
1. *Show server generating initial HTML*
   #+BEGIN_SRC lisp :exports code
   (defparameter *initial-todos* 
     '((:id "1" :text "Learn Lisp" :completed-p t)
       (:id "2" :text "Build isomorphic app" :completed-p nil)))
   
   (render-to-html 
    (make-instance 'todo-list :items *initial-todos*))
   #+END_SRC

2. *Show the generated HTML in browser*
3. *Demonstrate fast initial page load*

*** Client-Side Hydration (1.5 minutes)
1. *Show JavaScript compilation of same components*
2. *Demonstrate client-side state management*
   #+BEGIN_SRC lisp :exports code
   (dispatch '(:type :add-todo :payload (:text "Write ELS talk")))
   #+END_SRC

3. *Show seamless transition from server to client rendering*

*** Unified Development (1 minute)
1. *Make a change to component definition*
2. *Show automatic updates in both server and client*
3. *Demonstrate shared state synchronization*

** Key Benefits
- Single codebase for frontend and backend
- Leverages Lisp's macro system for powerful abstractions
- Eliminates JavaScript/TypeScript complexity
- Maintains Lisp's interactive development experience
- Enables true code reuse between environments

** Technical Considerations
- JavaScript interop for browser APIs
- Performance optimization for transpiled code
- SEO and accessibility compliance
- Bundle size management
- Browser compatibility

** Current Implementation Status
- [x] Basic component system (50% complete)
- [ ] JavaScript transpiler (40% complete)
- [x] State management framework (60% complete)
- [ ] Browser runtime optimization (30% complete)
- [ ] Development tooling (20% complete)

* Talk 5: Practical Protocol-Oriented Programming in Common Lisp
:PROPERTIES:
:CUSTOM_ID: protocol-programming
:EXPORT_TITLE: Practical Protocol-Oriented Programming in Common Lisp
:END:

** Abstract
A design methodology that uses Common Lisp's generic functions and method combinations to create flexible, composable systems through protocol definitions rather than inheritance hierarchies.

** Core Philosophy
Instead of asking "what is this thing?" (inheritance), protocol-oriented programming asks "what can this thing do?" This approach leads to more flexible and testable code by focusing on capabilities and behaviors.

** Protocol Design Patterns
#+BEGIN_SRC mermaid :file presentations/05-protocol-programming/slides/protocol-architecture.png :exports both
graph TD
    subgraph "Traditional OOP"
        A[Base Class] --> B[Derived Class 1]
        A --> C[Derived Class 2]
        A --> D[Derived Class 3]
        B --> E[Complex Inheritance]
        C --> E
    end
    
    subgraph "Protocol-Oriented Design"
        F[Protocol 1: Serializable]
        G[Protocol 2: Cacheable]
        H[Protocol 3: Validatable]
        
        I[Type A] -.-> F
        I -.-> G
        J[Type B] -.-> F
        J -.-> H
        K[Type C] -.-> G
        K -.-> H
    end
    
    subgraph "Composition Benefits"
        L[Mix and Match Protocols]
        M[Independent Testing]
        N[Easy Extension]
        O[Clear Contracts]
    end
    
    F --> L
    G --> L
    H --> L
    L --> M
    L --> N
    L --> O
#+END_SRC

** Protocol Definition Framework
#+BEGIN_SRC lisp :tangle presentations/05-protocol-programming/code/protocols.lisp :exports code
(defpackage :protocol-programming
  (:use :cl)
  (:export :defprotocol :implement-protocol :protocol-implemented-p :require-protocol))

(in-package :protocol-programming)

(defmacro defprotocol (name &body method-specs)
  "Define a protocol as a set of generic function signatures"
  `(progn
     ;; Create protocol registry entry
     (defvar ,(intern (format nil "*~A-PROTOCOL*" name)) 
       (make-protocol ',name ',method-specs))
     
     ;; Define generic functions for each method
     ,@(mapcar (lambda (spec)
                 (destructuring-bind (method-name lambda-list &optional documentation)
                     spec
                   `(defgeneric ,method-name ,lambda-list
                      ,@(when documentation `((:documentation ,documentation))))))
               method-specs)
     
     ;; Create protocol checker
     (defun ,(intern (format nil "~A-PROTOCOL-P" name)) (object)
       ,(format nil "Check if object implements the ~A protocol" name)
       (protocol-implemented-p object ',name))
     
     ;; Export protocol name
     ',name))

(defstruct protocol
  name
  methods
  implementations)

(defvar *protocols* (make-hash-table))

(defun make-protocol (name method-specs)
  "Create a protocol definition"
  (let ((protocol (make-protocol :name name :methods method-specs)))
    (setf (gethash name *protocols*) protocol)
    protocol))

(defmacro implement-protocol (protocol-name type &body method-implementations)
  "Implement a protocol for a specific type"
  `(progn
     ,@(mapcar (lambda (impl)
                 (destructuring-bind (method-name args &body body) impl
                   `(defmethod ,method-name ,(cons `(,(first args) ,type) (rest args))
                      ,@body)))
               method-implementations)
     
     ;; Register implementation
     (register-protocol-implementation ',protocol-name ',type)
     
     ;; Verify implementation completeness
     (verify-protocol-implementation ',protocol-name ',type)))

(defun register-protocol-implementation (protocol-name type)
  "Register that a type implements a protocol"
  (let ((protocol (gethash protocol-name *protocols*)))
    (when protocol
      (pushnew type (protocol-implementations protocol)))))

(defun protocol-implemented-p (object protocol-name)
  "Check if an object's type implements a protocol"
  (let ((protocol (gethash protocol-name *protocols*))
        (object-type (type-of object)))
    (when protocol
      (member object-type (protocol-implementations protocol)))))

(defun verify-protocol-implementation (protocol-name type)
  "Verify that all protocol methods are implemented for a type"
  (let ((protocol (gethash protocol-name *protocols*)))
    (when protocol
      (dolist (method-spec (protocol-methods protocol))
        (let ((method-name (first method-spec))
              (lambda-list (second method-spec)))
          (unless (find-method (symbol-function method-name)
                               '() 
                               (cons type (rest lambda-list))
                               nil)
            (warn "Method ~A not implemented for type ~A in protocol ~A"
                  method-name type protocol-name)))))))

;; Example protocol definitions
(defprotocol serializable
  (serialize (object) "Convert object to serializable representation")
  (deserialize (data type) "Reconstruct object from serialized data"))

(defprotocol cacheable
  (cache-key (object) "Generate unique cache key for object")
  (cache-ttl (object) "Return time-to-live for cached object")
  (invalidate-cache (object) "Mark cached object as invalid"))

(defprotocol validatable
  (validate (object) "Validate object state, return T if valid")
  (validation-errors (object) "Return list of validation errors")
  (fix-validation-errors (object) "Attempt to fix validation errors"))
#+END_SRC

*** Real-World Example: Document Management System
#+BEGIN_SRC lisp :tangle presentations/05-protocol-programming/code/document-system.lisp :exports code
(defpackage :document-system
  (:use :cl :protocol-programming)
  (:export :document :pdf-document :markdown-document :image-document))

(in-package :document-system)

;; Base document structure
(defclass document ()
  ((title :initarg :title :accessor document-title)
   (author :initarg :author :accessor document-author)
   (created-date :initarg :created-date :accessor document-created-date)
   (content :initarg :content :accessor document-content)))

;; Specific document types
(defclass pdf-document (document)
  ((page-count :initarg :page-count :accessor pdf-page-count)
   (file-path :initarg :file-path :accessor pdf-file-path)))

(defclass markdown-document (document)
  ((raw-markdown :initarg :raw-markdown :accessor markdown-raw-content)
   (rendered-html :initarg :rendered-html :accessor markdown-rendered-html)))

(defclass image-document (document)
  ((width :initarg :width :accessor image-width)
   (height :initarg :height :accessor image-height)
   (format :initarg :format :accessor image-format)))

;; Implement serializable protocol for different document types
(implement-protocol serializable pdf-document
  (serialize (doc)
    `(:type :pdf
      :title ,(document-title doc)
      :author ,(document-author doc)
      :created-date ,(document-created-date doc)
      :page-count ,(pdf-page-count doc)
      :file-path ,(pdf-file-path doc)))
  
  (deserialize (data type)
    (make-instance 'pdf-document
                   :title (getf data :title)
                   :author (getf data :author)
                   :created-date (getf data :created-date)
                   :page-count (getf data :page-count)
                   :file-path (getf data :file-path))))

(implement-protocol serializable markdown-document
  (serialize (doc)
    `(:type :markdown
      :title ,(document-title doc)
      :author ,(document-author doc)
      :created-date ,(document-created-date doc)
      :raw-markdown ,(markdown-raw-content doc)))
  
  (deserialize (data type)
    (let ((doc (make-instance 'markdown-document
                              :title (getf data :title)
                              :author (getf data :author)
                              :created-date (getf data :created-date)
                              :raw-markdown (getf data :raw-markdown))))
      ;; Render markdown to HTML
      (setf (markdown-rendered-html doc) 
            (render-markdown-to-html (getf data :raw-markdown)))
      doc)))

;; Implement cacheable protocol
(implement-protocol cacheable pdf-document
  (cache-key (doc)
    (format nil "pdf:~A:~A" (document-title doc) (pdf-file-path doc)))
  
  (cache-ttl (doc)
    (* 24 60 60)) ; 24 hours
  
  (invalidate-cache (doc)
    (remove-from-cache (cache-key doc))))

(implement-protocol cacheable markdown-document
  (cache-key (doc)
    (format nil "md:~A:~A" (document-title doc) 
            (sxhash (markdown-raw-content doc))))
  
  (cache-ttl (doc)
    (* 60 60)) ; 1 hour (shorter for dynamic content)
  
  (invalidate-cache (doc)
    (remove-from-cache (cache-key doc))))

;; Implement validatable protocol
(implement-protocol validatable document
  (validate (doc)
    (null (validation-errors doc)))
  
  (validation-errors (doc)
    (let ((errors '()))
      (unless (document-title doc)
        (push "Document must have a title" errors))
      (unless (document-author doc)
        (push "Document must have an author" errors))
      (unless (document-created-date doc)
        (push "Document must have a creation date" errors))
      errors))
  
  (fix-validation-errors (doc)
    (unless (document-title doc)
      (setf (document-title doc) "Untitled Document"))
    (unless (document-author doc)
      (setf (document-author doc) "Unknown Author"))
    (unless (document-created-date doc)
      (setf (document-created-date doc) (get-universal-time)))
    doc))

;; Protocol-based document processing
(defun process-documents (documents)
  "Process a list of documents using their implemented protocols"
  (dolist (doc documents)
    ;; Validate all documents
    (when (validatable-protocol-p doc)
      (unless (validate doc)
        (format t "Fixing validation errors for ~A~%" (document-title doc))
        (fix-validation-errors doc)))
    
    ;; Cache serializable documents
    (when (and (serializable-protocol-p doc)
               (cacheable-protocol-p doc))
      (let ((cache-key (cache-key doc))
            (serialized-data (serialize doc)))
        (store-in-cache cache-key serialized-data (cache-ttl doc))
        (format t "Cached ~A with key ~A~%" (document-title doc) cache-key)))
    
    ;; Additional processing based on available protocols
    (format t "Processed ~A (~A)~%" 
            (document-title doc) 
            (type-of doc))))

;; Utility functions
(defvar *cache* (make-hash-table :test #'equal))

(defun store-in-cache (key data ttl)
  "Store data in cache with TTL"
  (setf (gethash key *cache*) 
        (list :data data :expires (+ (get-universal-time) ttl))))

(defun remove-from-cache (key)
  "Remove item from cache"
  (remhash key *cache*))

(defun render-markdown-to-html (markdown)
  "Placeholder for markdown rendering"
  (format nil "<p>~A</p>" markdown))
#+END_SRC

** Demo Script
*** Setup (1 minute)
1. *Show traditional inheritance problems*
   - Diamond problem
   - Tight coupling
   - Difficult testing

2. *Introduce protocol-oriented alternative*

### Protocol Definition (1.5 minutes)
1. *Define protocols for document management*
   #+BEGIN_SRC lisp :exports code
   (defprotocol serializable
     (serialize (object))
     (deserialize (data type)))
   #+END_SRC

2. *Show protocol composition*
   #+BEGIN_SRC lisp :exports code
   (defprotocol cacheable
     (cache-key (object))
     (cache-ttl (object)))
   #+END_SRC

### Implementation (1.5 minutes)
1. *Implement protocols for different document types*
2. *Show how same type can implement multiple protocols*
3. *Demonstrate protocol checking*
   #+BEGIN_SRC lisp :exports code
   (serializable-protocol-p my-pdf-doc) ; => T
   (cacheable-protocol-p my-image-doc)  ; => NIL
   #+END_SRC

### Practical Benefits (1 minute)
1. *Show protocol-based document processing*
2. *Demonstrate easy extension with new document types*
3. *Show independent testing of protocol implementations*

## Key Advantages
- **Composition over Inheritance**: Mix and match capabilities
- **Clear Contracts**: Protocols define explicit interfaces
- **Easy Testing**: Test protocol implementations independently
- **Flexible Extension**: Add new types without modifying existing code
- **Reduced Coupling**: Components depend on protocols, not concrete types

## Comparison with Other Languages
- **Swift**: Similar protocol system, but Lisp's macros enable more powerful abstractions
- **Rust**: Traits provide similar functionality, but less runtime flexibility
- **Go**: Interfaces are similar, but Lisp's generic functions are more powerful
- **Java/C#**: Interfaces require explicit declaration, protocols are implicit in Lisp

## Implementation Challenges
- Performance considerations with dynamic dispatch
- Protocol documentation and discoverability
- Integration with existing CLOS-based codebases
- Tooling support for protocol analysis

## Current Status
- [x] Core protocol definition system (80% complete)
- [x] Implementation verification (70% complete)
- [ ] Development tooling integration (40% complete)
- [ ] Performance optimization (30% complete)
- [ ] Documentation generation (50% complete)

* Selection Matrix and Evaluation
:PROPERTIES:
:EXPORT_TITLE: Talk Selection and Development Plan
:END:

** Evaluation Criteria

| Talk | Novelty | Impact | Demo | Feasibility | Community Interest | Total Score |
|------|---------|--------|------|-------------|-------------------|-------------|
| Bidirectional LLM | 9 | 8 | 9 | 7 | 9 | 42/50 |
| REPL Observability | 7 | 9 | 8 | 8 | 8 | 40/50 |
| Incremental Types | 8 | 7 | 6 | 6 | 7 | 34/50 |
| Web Components | 8 | 6 | 7 | 5 | 6 | 32/50 |
| Protocol Programming | 6 | 8 | 7 | 9 | 7 | 37/50 |

** Development Timeline

*** Phase 1: Exploration (June - August 2025)
- Focus on top 3 scoring talks
- Build proof-of-concept implementations
- Gather community feedback

*** Phase 2: Development (September - December 2025)
- Complete implementation of selected talks
- Create compelling demos
- Refine presentation materials  

*** Phase 3: Selection (January - February 2026)
- Final evaluation based on implementation progress
- Select 1-2 talks for submission
- Prepare submission materials

*** Phase 4: Refinement (February - April 2026)
- Polish selected presentations
- Practice and refine demos
- Submit to ELS 2026

** Implementation Notes

#+BEGIN_SRC lisp :tangle implementation-notes.lisp :exports code
;; Development tracking
(defvar *talk-progress* 
  '((:bidirectional-llm 
     :concept-complete 70
     :implementation 40
     :demo 20
     :presentation 0)
    (:repl-observability
     :concept-complete 60
     :implementation 30
     :demo 10
     :presentation 0)
    (:incremental-types
     :concept-complete 50
     :implementation 20
     :demo 0
     :presentation 5)
    (:web-components
     :concept-complete 40
     :implementation 15
     :demo 5
     :presentation 0)
    (:protocol-programming
     :concept-complete 80
     :implementation 60
     :demo 30
     :presentation 10)))

(defun calculate-readiness (talk-id)
  "Calculate overall readiness score for a talk"
  (let ((progress (getf *talk-progress* talk-id)))
    (when progress
      (/ (+ (getf progress :concept-complete)
            (getf progress :implementation)
            (getf progress :demo)
            (getf progress :presentation))
         4))))

;; Example: (calculate-readiness :bidirectional-llm) => 32.5
#+END_SRC

** Export Configuration

#+BEGIN_SRC emacs-lisp :exports code
;; Org-mode export settings for presentation generation
(setq org-export-with-toc t)
(setq org-export-with-section-numbers t)
(setq org-html-head-extra "
<style>
  body { font-family: 'Source Sans Pro', sans-serif; }
  .title { color: #2E3440; border-bottom: 2px solid #5E81AC; }
  h2 { color: #5E81AC; }
  h3 { color: #81A1C1; }
  pre { background-color: #3B4252; color: #D8DEE9; padding: 10px; }
  .src { border-left: 4px solid #5E81AC; }
</style>")
#+END_SRC

* Conclusion

These five lightning talk proposals represent different aspects of advancing Common Lisp in modern software development. Each builds upon current community work while exploring new directions that could benefit Lisp developers and the broader programming community.

The talks are designed to:
- Showcase Lisp's unique strengths in modern contexts
- Address real problems faced by developers today  
- Demonstrate practical applications of advanced Lisp features
- Inspire further development and research

Based on the evaluation matrix, the **Bidirectional Code Generation with Lisp and LLMs** talk shows the most promise, combining high novelty and impact with strong demonstration potential. The **REPL-Driven Observability** talk follows closely, addressing a critical need in distributed systems development.

The development timeline allows for parallel exploration initially, with progressive focus on the most promising candidates as implementations mature.
